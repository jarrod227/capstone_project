/**
 * @file main.c
 * @brief EOG Cursor Control - STM32 Firmware
 *
 * Data acquisition node: reads EOG (ADC) + IMU gyro (I2C),
 * transmits CSV packets over UART at 200Hz.
 *
 * Hardware connections:
 *   - AD8232 #1 OUT -> PA0 (ADC1 Channel 1) - vertical EOG
 *   - AD8232 #2 OUT -> PA4 (ADC2 Channel 1) - horizontal EOG
 *   - MPU9250 SDA   -> PB7 (I2C1)
 *   - MPU9250 SCL   -> PB6 (I2C1)
 *   - USB           -> USART2 (virtual COM port)
 *
 * Output format: "timestamp,eog_v,eog_h,gyro_x,gyro_y,gyro_z\r\n"
 *   - timestamp: milliseconds since boot (HAL_GetTick)
 *   - eog_v:     12-bit ADC value (0-4095) vertical EOG
 *   - eog_h:     12-bit ADC value (0-4095) horizontal EOG
 *   - gyro_x/y/z: raw 16-bit signed gyroscope readings
 *
 * NOTE: This is reference code. Pin assignments and peripheral
 * configuration should be generated via STM32CubeMX for your
 * specific board. Place custom code within USER CODE blocks.
 */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "mpu9250.h"
#include <stdio.h>
#include <string.h>

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */
static char tx_buf[2][80];                /* Ping-pong buffers for DMA */
static volatile uint8_t tx_idx = 0;       /* Index of buffer being filled */
static volatile uint8_t dma_busy = 0;     /* 1 while DMA transfer in progress */
static volatile uint8_t tick_200hz = 0;   /* Set by TIM6 ISR every 5ms */
static MPU9250_GyroRaw gyro_data;
/* USER CODE END PV */

/* Extern handles (generated by CubeMX) */
extern ADC_HandleTypeDef hadc1;
extern ADC_HandleTypeDef hadc2;
extern I2C_HandleTypeDef hi2c1;
extern UART_HandleTypeDef huart2;
extern DMA_HandleTypeDef hdma_usart2_tx;
extern TIM_HandleTypeDef htim6;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);
static void MX_ADC2_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_DMA_Init(void);
static void MX_TIM6_Init(void);

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{
    /* MCU Configuration */
    HAL_Init();
    SystemClock_Config();

    /* Initialize peripherals (CubeMX generated) */
    MX_GPIO_Init();
    MX_DMA_Init();
    MX_ADC1_Init();
    MX_ADC2_Init();
    MX_I2C1_Init();
    MX_USART2_UART_Init();
    MX_TIM6_Init();

    /* USER CODE BEGIN 2 */

    /* Initialize IMU */
    uint8_t imu_ok = 0;
    if (MPU9250_Init(&hi2c1) == HAL_OK) {
        imu_ok = 1;
    } else {
        /* IMU init failed - turn on LED as warning, but continue */
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
    }

    /* Brief startup delay for sensor stabilization */
    HAL_Delay(500);

    /* Start 200Hz timer — drives the main loop via interrupt flag */
    HAL_TIM_Base_Start_IT(&htim6);

    /* USER CODE END 2 */

    /* Main loop: acquire and transmit at 200Hz (TIM6-driven) */
    /* USER CODE BEGIN WHILE */
    while (1)
    {
        /* Wait for TIM6 interrupt (precise 5ms period) */
        while (!tick_200hz) {}
        tick_200hz = 0;

        uint32_t timestamp = HAL_GetTick();

        /* --- Read vertical EOG via ADC1 --- */
        HAL_ADC_Start(&hadc1);
        HAL_ADC_PollForConversion(&hadc1, 10);
        uint16_t eog_v = HAL_ADC_GetValue(&hadc1);
        HAL_ADC_Stop(&hadc1);

        /* --- Read horizontal EOG via ADC2 --- */
        HAL_ADC_Start(&hadc2);
        HAL_ADC_PollForConversion(&hadc2, 10);
        uint16_t eog_h = HAL_ADC_GetValue(&hadc2);
        HAL_ADC_Stop(&hadc2);

        /* --- Read IMU gyroscope via I2C --- */
        if (imu_ok && MPU9250_ReadGyro(&hi2c1, &gyro_data) != HAL_OK) {
            /* I2C failed — zero out to avoid stale data causing drift */
            gyro_data.x = 0;
            gyro_data.y = 0;
            gyro_data.z = 0;
        }

        /* --- Format CSV into current fill buffer --- */
        int len = snprintf(tx_buf[tx_idx], sizeof(tx_buf[0]),
                           "%lu,%u,%u,%d,%d,%d\r\n",
                           timestamp,
                           eog_v,
                           eog_h,
                           gyro_data.x,
                           gyro_data.y,
                           gyro_data.z);

        /* --- Transmit via DMA (non-blocking) --- */
        if (!dma_busy) {
            uint8_t send_idx = tx_idx;
            tx_idx ^= 1;  /* Swap to other buffer for next iteration */
            dma_busy = 1;
            HAL_UART_Transmit_DMA(&huart2, (uint8_t *)tx_buf[send_idx], len);
        }
    }
    /* USER CODE END WHILE */
}

/* --- DMA / Timer Callbacks --- */

/**
 * @brief  UART DMA transmit complete callback.
 *         Clears the busy flag so next frame can be sent.
 */
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART2) {
        dma_busy = 0;
    }
}

/**
 * @brief  TIM6 period elapsed callback (every 5ms = 200Hz).
 *         Sets the tick flag to trigger the next acquisition cycle.
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == TIM6) {
        tick_200hz = 1;
    }
}

/*
 * NOTE: The following initialization functions are stubs.
 * In a real project, STM32CubeMX generates these automatically.
 * Configure the following in CubeMX:
 *
 * ADC1:
 *   - Channel 0 (PA0), 12-bit resolution
 *   - Single conversion mode
 *   - Software trigger
 *   - Vertical EOG (AD8232 #1)
 *
 * ADC2:
 *   - Channel 1 (PA4), 12-bit resolution
 *   - Single conversion mode
 *   - Software trigger
 *   - Horizontal EOG (AD8232 #2)
 *
 * I2C1:
 *   - PB6 (SCL), PB7 (SDA)
 *   - 400kHz (Fast Mode)
 *
 * USART2:
 *   - 115200 baud, 8N1
 *   - TX: PA2, RX: PA3
 *
 * Clock:
 *   - Use HSI or HSE depending on your board
 *   - Target: 80MHz system clock (adjust for your MCU)
 */

void SystemClock_Config(void)
{
    /* Generated by CubeMX - configure for your specific board */
}

static void MX_GPIO_Init(void)
{
    /* Generated by CubeMX */
    __HAL_RCC_GPIOA_CLK_ENABLE();
}

static void MX_ADC1_Init(void)
{
    /* Generated by CubeMX
     * Key settings:
     *   Resolution: 12-bit
     *   Scan mode: Disabled (single channel)
     *   Continuous mode: Disabled
     *   Channel: 1 (PA0) - vertical EOG
     */
}

static void MX_ADC2_Init(void)
{
    /* Generated by CubeMX
     * Key settings:
     *   Resolution: 12-bit
     *   Scan mode: Disabled (single channel)
     *   Continuous mode: Disabled
     *   Channel: 1 (PA4) - horizontal EOG
     */
}

static void MX_I2C1_Init(void)
{
    /* Generated by CubeMX
     * Key settings:
     *   Speed: 400kHz (Fast Mode)
     *   SCL: PB6
     *   SDA: PB7
     */
}

static void MX_USART2_UART_Init(void)
{
    /* Generated by CubeMX
     * Key settings:
     *   Baud rate: 115200
     *   Word length: 8 bits
     *   Stop bits: 1
     *   Parity: None
     *   DMA TX: DMA1 Channel 7 (linked to USART2_TX)
     */
}

static void MX_DMA_Init(void)
{
    /* Generated by CubeMX
     * Key settings:
     *   Enable DMA1 clock
     *   DMA1 Channel 7 → USART2_TX
     *   Direction: Memory to Peripheral
     *   Memory increment: Enable
     *   Peripheral increment: Disable
     *   Data alignment: Byte
     *   Mode: Normal (not circular)
     *   Priority: Low
     *   Enable DMA1_Channel7 IRQ in NVIC
     */
    __HAL_RCC_DMA1_CLK_ENABLE();
    HAL_NVIC_SetPriority(DMA1_Channel7_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(DMA1_Channel7_IRQn);
}

static void MX_TIM6_Init(void)
{
    /* Generated by CubeMX
     * Key settings:
     *   Clock source: Internal (APB1 = 8MHz)
     *   Prescaler: 79       → 8MHz / 80 = 100kHz tick
     *   Period:    499      → 100kHz / 500 = 200Hz overflow
     *   Auto-reload preload: Enable
     *   Enable TIM6 global IRQ in NVIC
     *
     * Result: TIM6 overflows every 5.000ms (200Hz exact)
     */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
    __disable_irq();
    while (1) {
    }
}
