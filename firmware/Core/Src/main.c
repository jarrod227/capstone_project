/**
 * @file main.c
 * @brief EOG Cursor Control - STM32 Firmware
 *
 * Data acquisition node: reads EOG (ADC) + IMU gyro (I2C),
 * transmits CSV packets over UART at 200Hz.
 *
 * Hardware connections:
 *   - AD8232 #1 OUT -> PA0 (ADC1 Channel 1) - vertical EOG
 *   - AD8232 #2 OUT -> PA4 (ADC2 Channel 1) - horizontal EOG
 *   - MPU9250 SDA   -> PB7 (I2C1)
 *   - MPU9250 SCL   -> PB6 (I2C1)
 *   - USB           -> USART2 (virtual COM port)
 *
 * Output format: "timestamp,eog_v,eog_h,gyro_x,gyro_y,gyro_z\r\n"
 *   - timestamp: milliseconds since boot (HAL_GetTick)
 *   - eog_v:     12-bit ADC value (0-4095) vertical EOG
 *   - eog_h:     12-bit ADC value (0-4095) horizontal EOG
 *   - gyro_x/y/z: raw 16-bit signed gyroscope readings
 *
 * NOTE: This is reference code. Pin assignments and peripheral
 * configuration should be generated via STM32CubeMX for your
 * specific board. Place custom code within USER CODE blocks.
 */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "mpu9250.h"
#include <stdio.h>
#include <string.h>

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */
static char tx_buf[80];
static MPU9250_GyroRaw gyro_data;
/* USER CODE END PV */

/* Extern handles (generated by CubeMX) */
extern ADC_HandleTypeDef hadc1;
extern ADC_HandleTypeDef hadc2;
extern I2C_HandleTypeDef hi2c1;
extern UART_HandleTypeDef huart2;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);
static void MX_ADC2_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART2_UART_Init(void);

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{
    /* MCU Configuration */
    HAL_Init();
    SystemClock_Config();

    /* Initialize peripherals (CubeMX generated) */
    MX_GPIO_Init();
    MX_ADC1_Init();
    MX_ADC2_Init();
    MX_I2C1_Init();
    MX_USART2_UART_Init();

    /* USER CODE BEGIN 2 */

    /* Initialize IMU */
    uint8_t imu_ok = 0;
    if (MPU9250_Init(&hi2c1) == HAL_OK) {
        imu_ok = 1;
    } else {
        /* IMU init failed - turn on LED as warning, but continue */
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
    }

    /* Brief startup delay for sensor stabilization */
    HAL_Delay(500);

    /* USER CODE END 2 */

    /* Main loop: acquire and transmit at ~200Hz (5ms period) */
    /* USER CODE BEGIN WHILE */
    while (1)
    {
        uint32_t tick_start = HAL_GetTick();

        /* --- Read vertical EOG via ADC1 --- */
        HAL_ADC_Start(&hadc1);
        HAL_ADC_PollForConversion(&hadc1, 10);
        uint16_t eog_v = HAL_ADC_GetValue(&hadc1);
        HAL_ADC_Stop(&hadc1);

        /* --- Read horizontal EOG via ADC2 --- */
        HAL_ADC_Start(&hadc2);
        HAL_ADC_PollForConversion(&hadc2, 10);
        uint16_t eog_h = HAL_ADC_GetValue(&hadc2);
        HAL_ADC_Stop(&hadc2);

        /* --- Read IMU gyroscope via I2C --- */
        if (imu_ok && MPU9250_ReadGyro(&hi2c1, &gyro_data) != HAL_OK) {
            /* I2C failed â€” zero out to avoid stale data causing drift */
            gyro_data.x = 0;
            gyro_data.y = 0;
            gyro_data.z = 0;
        }

        /* --- Format and transmit CSV packet --- */
        int len = snprintf(tx_buf, sizeof(tx_buf),
                           "%lu,%u,%u,%d,%d,%d\r\n",
                           tick_start,
                           eog_v,
                           eog_h,
                           gyro_data.x,
                           gyro_data.y,
                           gyro_data.z);

        HAL_UART_Transmit(&huart2, (uint8_t *)tx_buf, len, 50);

        /* --- Maintain 200Hz sample rate --- */
        uint32_t elapsed = HAL_GetTick() - tick_start;
        if (elapsed < 5) {
            HAL_Delay(5 - elapsed);
        }
    }
    /* USER CODE END WHILE */
}

/*
 * NOTE: The following initialization functions are stubs.
 * In a real project, STM32CubeMX generates these automatically.
 * Configure the following in CubeMX:
 *
 * ADC1:
 *   - Channel 0 (PA0), 12-bit resolution
 *   - Single conversion mode
 *   - Software trigger
 *   - Vertical EOG (AD8232 #1)
 *
 * ADC2:
 *   - Channel 1 (PA4), 12-bit resolution
 *   - Single conversion mode
 *   - Software trigger
 *   - Horizontal EOG (AD8232 #2)
 *
 * I2C1:
 *   - PB6 (SCL), PB7 (SDA)
 *   - 400kHz (Fast Mode)
 *
 * USART2:
 *   - 115200 baud, 8N1
 *   - TX: PA2, RX: PA3
 *
 * Clock:
 *   - Use HSI or HSE depending on your board
 *   - Target: 80MHz system clock (adjust for your MCU)
 */

void SystemClock_Config(void)
{
    /* Generated by CubeMX - configure for your specific board */
}

static void MX_GPIO_Init(void)
{
    /* Generated by CubeMX */
    __HAL_RCC_GPIOA_CLK_ENABLE();
}

static void MX_ADC1_Init(void)
{
    /* Generated by CubeMX
     * Key settings:
     *   Resolution: 12-bit
     *   Scan mode: Disabled (single channel)
     *   Continuous mode: Disabled
     *   Channel: 1 (PA0) - vertical EOG
     */
}

static void MX_ADC2_Init(void)
{
    /* Generated by CubeMX
     * Key settings:
     *   Resolution: 12-bit
     *   Scan mode: Disabled (single channel)
     *   Continuous mode: Disabled
     *   Channel: 1 (PA4) - horizontal EOG
     */
}

static void MX_I2C1_Init(void)
{
    /* Generated by CubeMX
     * Key settings:
     *   Speed: 400kHz (Fast Mode)
     *   SCL: PB6
     *   SDA: PB7
     */
}

static void MX_USART2_UART_Init(void)
{
    /* Generated by CubeMX
     * Key settings:
     *   Baud rate: 115200
     *   Word length: 8 bits
     *   Stop bits: 1
     *   Parity: None
     */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
    __disable_irq();
    while (1) {
    }
}
